const path = require('path')
const {promisify} = require('util')
const {createHash} = require('crypto')
const {createGzip} = require('zlib')
const fs = require('fs')
const {createReadStream, createWriteStream} = fs
const stat = promisify @ fs.stat
const copyFile = promisify @ fs.copyFile
const writeFile = promisify @ fs.writeFile

module.exports = exports = hash_and_gzip_local_rollup_plugin
export default hash_and_gzip_local_rollup_plugin

export function hash_and_gzip_local_rollup_plugin() ::
  const minSize = 14e3
  return @:
    name: 'hash-gzip-local-plugin'
    async onwrite(buildOpts) ::
      try ::
        const file = buildOpts.file
        const [h, compressed] = await Promise.all @#
            hashFile(file), compressFile(file)

        const fname_parts = path.parse(file)
        fname_parts.base = null
        fname_parts.ext = `.${h}${fname_parts.ext}`

        const dest_hash = path.format(fname_parts)
        await Promise.all @#
            copyFile @ file, dest_hash
          , compressed && copyFile @ file+'.gz', dest_hash+'.gz'
        await writeFile @ file+'.lnk', path.basename(dest_hash)
      catch err ::
        console.error @ "ERROR", err

  function hashFile(file, algorithm='sha1') ::
    return new Promise @ function(resolve, reject) ::
      createReadStream(file)
        .pipe @ createHash(algorithm)
        .on @ 'error', reject
        .on @ 'data', function(h) ::
          resolve @ h.toString('hex')

  function compressFile(file) ::
    return stat(file).then @ stat => ::
      if stat.size <= minSize :: return false
      return new Promise @ function(resolve, reject) ::
        createReadStream(file)
          .pipe @ createGzip()
          .pipe @ createWriteStream @ `${file}.gz`
          .on @ 'error', reject
          .on @ 'finish', () => resolve(true)

