const path = require('path')

const rollup = require('rollup')
const chokidar = require('chokidar')

export * from './rollup_jsy.jsy'
export * from './rollup_deps.jsy'
export * from './rollup_std.jsy'

import {stdPrePluginsForEnv, stdPostPluginsForEnv} from './rollup_std.jsy'

export function bundle({source, opt, globalModules, plugins, format, amd}) ::
  if 'string' !== typeof source :: throw new TypeError @ `Expected string source parameter`
  if null == opt :: throw new TypeError @ `Expected valid "opt" object parameter`
  if null == globalModules :: globalModules = {}
  if null == plugins :: plugins = []

  opt = Object.assign @ {}, opt, @:
    source: path.parse @ source
    suffix: opt.production ? '.min' : ''

  const input = @{}
    input: source
    plugins: _flatten @
      stdPrePluginsForEnv(opt)
      plugins || []
      stdPostPluginsForEnv(opt)
    external(module) ::
      return !! globalModules[module]

  if ! format ::
    format = amd ? 'amd' : 'iife'

  const output = @{}
    format
    name: opt.source.name
    file: `./dist/public/${opt.source.name}${opt.suffix}.js`
    sourcemap: opt.sourcemap
    globals(module) ::
      return globalModules[module]

  if amd && 'amd' === format :: output.amd = amd

  return asRollupBuildClosure @:
    input, output, opt

function _flatten(...args) ::
  const plugins = args
    .reduce @ (a,b) => a.concat(b), []
    .reduce @ (a,b) => a.concat(b), []
    .filter @ e => e
  return plugins


export function asRollupBuildClosure({input, output, opt}) ::
  let bundle
  return async function () ::
    input.cache = bundle
    console.log @ `Building rollup bundle "${opt.source.name}"`
    bundle = await rollup.rollup(input)
    await bundle.write(output)

export function buildAll(...listOfBuilderLists) ::
  return Promise.all @
    listOfBuilderLists
      .reduce @ (a, b) => [].concat @ a || [], b || []
      .map @ builder => builder()

export async function watchAndBuild(...listOfRebuilderLists) ::
  let inprogress_changes = null
  async function rebuild_for_change(path) ::
    if null !== inprogress_changes ::
      return inprogress_changes.push(path)

    inprogress_changes = [path]
    await new Promise @ resolve => setTimeout(resolve, 50)
    inprogress_changes = null

    console.time('rebuild for changes')
    try ::
      await buildAll @ ... listOfRebuilderLists
      console.timeEnd('rebuild for changes')
    catch err ::
      console.error @ err

  ::
    const w_app = chokidar
      .watch @ './app', @:
        ignoreInitial: true
        ignorePermissionErrors: true

      .on @ 'change'
        rebuild_for_change

    const w_setup = chokidar
      .watch @
        @# './package.json', './rollup.cfg.jsy', './tools'
        @: ignoreInitial: true

      .on @ 'change'
        path => ::
          console.log @ `Setup changed; shutting down watchers ("${path}")`
          w_app.close()
          w_setup.close()
